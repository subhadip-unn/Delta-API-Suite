"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_components_JsonDiff_tsx",{

/***/ "(app-pages-browser)/./lib/comparison-engine.ts":
/*!**********************************!*\
  !*** ./lib/comparison-engine.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareJsonData: function() { return /* binding */ compareJsonData; }\n/* harmony export */ });\n// Advanced Comparison Engine - Migrated from React project\n// This is the core comparison logic that makes our product world-class\n// Severity classification based on path and type\nconst getSeverity = (path, type)=>{\n    // Critical paths that should never change\n    const criticalPaths = [\n        \"id\",\n        \"status\",\n        \"error\",\n        \"success\",\n        \"code\"\n    ];\n    if (criticalPaths.some((critical)=>path.includes(critical))) {\n        return \"critical\";\n    }\n    // High importance paths\n    const highPaths = [\n        \"data\",\n        \"result\",\n        \"response\",\n        \"message\",\n        \"title\",\n        \"name\"\n    ];\n    if (highPaths.some((high)=>path.includes(high))) {\n        return \"high\";\n    }\n    // Medium importance paths\n    const mediumPaths = [\n        \"count\",\n        \"total\",\n        \"size\",\n        \"length\",\n        \"timestamp\",\n        \"date\"\n    ];\n    if (mediumPaths.some((medium)=>path.includes(medium))) {\n        return \"medium\";\n    }\n    // Type-based severity\n    if (type === \"type-changed\") return \"high\";\n    if (type === \"missing\" || type === \"extra\") return \"medium\";\n    return \"low\";\n};\n// Advanced similarity matching for intelligent array comparison\nconst findBestMatch = (itemA, arrayB, usedIndices)=>{\n    let bestMatch = null;\n    let bestSimilarity = 0;\n    for(let i = 0; i < arrayB.length; i++){\n        if (usedIndices.has(i)) continue;\n        const itemB = arrayB[i];\n        const similarity = calculateSimilarity(itemA, itemB);\n        if (similarity > bestSimilarity && similarity >= 0.5) {\n            bestMatch = {\n                match: itemB,\n                index: i,\n                similarity\n            };\n            bestSimilarity = similarity;\n        }\n    }\n    return bestMatch;\n};\n// Calculate similarity between two objects (0-1 scale)\nconst calculateSimilarity = (a, b)=>{\n    if (a === b) return 1.0;\n    if (typeof a !== typeof b) return 0.0;\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length === 0 && b.length === 0) return 1.0;\n        if (a.length === 0 || b.length === 0) return 0.0;\n        // Calculate average similarity of array elements\n        const similarities = a.map((itemA)=>{\n            const bestMatch = findBestMatch(itemA, b, new Set());\n            return bestMatch ? bestMatch.similarity : 0;\n        });\n        return similarities.reduce((sum, sim)=>sum + sim, 0) / similarities.length;\n    }\n    if (typeof a === \"object\" && a !== null && b !== null) {\n        const keysA = Object.keys(a);\n        const keysB = Object.keys(b);\n        const allKeys = new Set([\n            ...keysA,\n            ...keysB\n        ]);\n        if (allKeys.size === 0) return 1.0;\n        let matchingKeys = 0;\n        let totalSimilarity = 0;\n        for (const key of allKeys){\n            if (key in a && key in b) {\n                matchingKeys++;\n                totalSimilarity += calculateSimilarity(a[key], b[key]);\n            }\n        }\n        const keySimilarity = matchingKeys / allKeys.size;\n        const valueSimilarity = matchingKeys > 0 ? totalSimilarity / matchingKeys : 0;\n        return (keySimilarity + valueSimilarity) / 2;\n    }\n    // For primitives, use string similarity\n    const strA = String(a);\n    const strB = String(b);\n    if (strA === strB) return 1.0;\n    if (strA.length === 0 && strB.length === 0) return 1.0;\n    if (strA.length === 0 || strB.length === 0) return 0.0;\n    // Simple Levenshtein distance-based similarity\n    const distance = levenshteinDistance(strA, strB);\n    const maxLength = Math.max(strA.length, strB.length);\n    return 1 - distance / maxLength;\n};\n// Levenshtein distance calculation\nconst levenshteinDistance = (str1, str2)=>{\n    const matrix = Array(str2.length + 1).fill(null).map(()=>Array(str1.length + 1).fill(null));\n    for(let i = 0; i <= str1.length; i++)matrix[0][i] = i;\n    for(let j = 0; j <= str2.length; j++)matrix[j][0] = j;\n    for(let j = 1; j <= str2.length; j++){\n        for(let i = 1; i <= str1.length; i++){\n            const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;\n            matrix[j][i] = Math.min(matrix[j][i - 1] + 1, matrix[j - 1][i] + 1, matrix[j - 1][i - 1] + indicator // substitution\n            );\n        }\n    }\n    return matrix[str2.length][str1.length];\n};\n// Count fields in an object for statistics\nconst countFields = (obj)=>{\n    if (obj === null || obj === undefined) return 0;\n    if (typeof obj !== \"object\") return 1;\n    if (Array.isArray(obj)) return obj.reduce((sum, item)=>sum + countFields(item), 0);\n    return Object.keys(obj).reduce((sum, key)=>sum + countFields(obj[key]), 0);\n};\n// Main comparison function - the heart of our product\nconst compareJsonData = function(obj1, obj2) {\n    let isOrderSensitive = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    const differences = [];\n    const compare = function(a, b) {\n        let path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"\";\n        if (typeof a !== typeof b) {\n            const severity = getSeverity(path, \"type-changed\");\n            differences.push({\n                path,\n                type: \"type-changed\",\n                severity,\n                oldValue: a,\n                newValue: b,\n                description: \"Type changed from \".concat(typeof a, \" to \").concat(typeof b)\n            });\n            return;\n        }\n        if (Array.isArray(a) && Array.isArray(b)) {\n            if (isOrderSensitive) {\n                // Order-sensitive array comparison (strict positional matching)\n                const maxLength = Math.max(a.length, b.length);\n                for(let i = 0; i < maxLength; i++){\n                    if (i >= a.length) {\n                        const severity = getSeverity(\"\".concat(path, \"[\").concat(i, \"]\"), \"extra\");\n                        differences.push({\n                            path: \"\".concat(path, \"[\").concat(i, \"]\"),\n                            type: \"extra\",\n                            severity,\n                            oldValue: undefined,\n                            newValue: b[i],\n                            description: \"Extra array item at position \".concat(i, \" (order-sensitive)\")\n                        });\n                    } else if (i >= b.length) {\n                        const severity = getSeverity(\"\".concat(path, \"[\").concat(i, \"]\"), \"missing\");\n                        differences.push({\n                            path: \"\".concat(path, \"[\").concat(i, \"]\"),\n                            type: \"missing\",\n                            severity,\n                            oldValue: a[i],\n                            newValue: undefined,\n                            description: \"Missing array item at position \".concat(i, \" (order-sensitive)\")\n                        });\n                    } else {\n                        compare(a[i], b[i], \"\".concat(path, \"[\").concat(i, \"]\"));\n                    }\n                }\n            } else {\n                // TRULY INTELLIGENT ORDER-INSENSITIVE ARRAY COMPARISON\n                // This is the core algorithm that makes our product world-class\n                const usedIndicesInB = new Set();\n                const unmatchedFromA = [];\n                // Phase 1: Find exact matches and high-similarity matches\n                for(let i = 0; i < a.length; i++){\n                    const itemA = a[i];\n                    const bestMatch = findBestMatch(itemA, b, usedIndicesInB);\n                    if (bestMatch && bestMatch.similarity >= 0.95) {\n                        // Exact or near-exact match found\n                        usedIndicesInB.add(bestMatch.index);\n                        if (bestMatch.similarity < 1.0) {\n                            // Items are similar but not identical - compare them for detailed differences\n                            compare(itemA, bestMatch.match, \"\".concat(path, \"[\").concat(i, \"]\"));\n                        }\n                    // If similarity is 1.0, items are identical - no differences to report\n                    } else if (bestMatch && bestMatch.similarity >= 0.7) {\n                        // Partial match - these are likely the same logical item with some changes\n                        usedIndicesInB.add(bestMatch.index);\n                        compare(itemA, bestMatch.match, \"\".concat(path, \"[\").concat(i, \"]\"));\n                    } else {\n                        // No good match found - this item might be missing from B\n                        unmatchedFromA.push({\n                            item: itemA,\n                            originalIndex: i\n                        });\n                    }\n                }\n                // Phase 2: Identify truly missing items (from A but not in B)\n                for (const unmatched of unmatchedFromA){\n                    const severity = getSeverity(\"\".concat(path, \"[\").concat(unmatched.originalIndex, \"]\"), \"missing\");\n                    differences.push({\n                        path: \"\".concat(path, \"[\").concat(unmatched.originalIndex, \"]\"),\n                        type: \"missing\",\n                        severity,\n                        oldValue: unmatched.item,\n                        newValue: undefined,\n                        description: \"Item from Live API not found in New API (no similar match found)\"\n                    });\n                }\n                // Phase 3: Identify truly extra items (in B but not matched with A)\n                for(let j = 0; j < b.length; j++){\n                    if (!usedIndicesInB.has(j)) {\n                        const severity = getSeverity(\"\".concat(path, \"[\").concat(j, \"]\"), \"extra\");\n                        differences.push({\n                            path: \"\".concat(path, \"[\").concat(j, \"]\"),\n                            type: \"extra\",\n                            severity,\n                            oldValue: undefined,\n                            newValue: b[j],\n                            description: \"New item in New API not found in Live API\"\n                        });\n                    }\n                }\n            }\n            return;\n        }\n        if (typeof a === \"object\" && a !== null && b !== null) {\n            const allKeys = new Set([\n                ...Object.keys(a),\n                ...Object.keys(b)\n            ]);\n            for (const key of allKeys){\n                const newPath = path ? \"\".concat(path, \".\").concat(key) : key;\n                if (!(key in a)) {\n                    const severity = getSeverity(newPath, \"extra\");\n                    differences.push({\n                        path: newPath,\n                        type: \"extra\",\n                        severity,\n                        oldValue: undefined,\n                        newValue: b[key],\n                        description: \"Property '\".concat(key, \"' exists only in right object\")\n                    });\n                } else if (!(key in b)) {\n                    const severity = getSeverity(newPath, \"missing\");\n                    differences.push({\n                        path: newPath,\n                        type: \"missing\",\n                        severity,\n                        oldValue: a[key],\n                        newValue: undefined,\n                        description: \"Property '\".concat(key, \"' exists only in left object\")\n                    });\n                } else {\n                    compare(a[key], b[key], newPath);\n                }\n            }\n            return;\n        }\n        if (a !== b) {\n            const severity = getSeverity(path, \"changed\");\n            differences.push({\n                path,\n                type: \"changed\",\n                severity,\n                oldValue: a,\n                newValue: b,\n                description: \"Value changed from '\".concat(a, \"' to '\").concat(b, \"'\")\n            });\n        }\n    };\n    compare(obj1, obj2);\n    // Calculate summary statistics\n    const totalFields = countFields(obj1) + countFields(obj2);\n    const differentFields = differences.filter((d)=>d.type === \"changed\" || d.type === \"type-changed\").length;\n    const missingFields = differences.filter((d)=>d.type === \"missing\").length;\n    const extraFields = differences.filter((d)=>d.type === \"extra\").length;\n    const identicalFields = Math.max(0, totalFields - differences.length);\n    // Calculate severity counts\n    const criticalDiffs = differences.filter((d)=>d.severity === \"critical\").length;\n    const highDiffs = differences.filter((d)=>d.severity === \"high\").length;\n    const mediumDiffs = differences.filter((d)=>d.severity === \"medium\").length;\n    const lowDiffs = differences.filter((d)=>d.severity === \"low\").length;\n    return {\n        identical: differences.length === 0,\n        differences,\n        summary: {\n            totalFields,\n            identicalFields,\n            differentFields,\n            missingFields,\n            extraFields,\n            criticalDiffs,\n            highDiffs,\n            mediumDiffs,\n            lowDiffs\n        }\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9jb21wYXJpc29uLWVuZ2luZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsMkRBQTJEO0FBQzNELHVFQUF1RTtBQTBCdkUsaURBQWlEO0FBQ2pELE1BQU1BLGNBQWMsQ0FBQ0MsTUFBY0M7SUFDakMsMENBQTBDO0lBQzFDLE1BQU1DLGdCQUFnQjtRQUFDO1FBQU07UUFBVTtRQUFTO1FBQVc7S0FBTztJQUNsRSxJQUFJQSxjQUFjQyxJQUFJLENBQUNDLENBQUFBLFdBQVlKLEtBQUtLLFFBQVEsQ0FBQ0QsWUFBWTtRQUMzRCxPQUFPO0lBQ1Q7SUFFQSx3QkFBd0I7SUFDeEIsTUFBTUUsWUFBWTtRQUFDO1FBQVE7UUFBVTtRQUFZO1FBQVc7UUFBUztLQUFPO0lBQzVFLElBQUlBLFVBQVVILElBQUksQ0FBQ0ksQ0FBQUEsT0FBUVAsS0FBS0ssUUFBUSxDQUFDRSxRQUFRO1FBQy9DLE9BQU87SUFDVDtJQUVBLDBCQUEwQjtJQUMxQixNQUFNQyxjQUFjO1FBQUM7UUFBUztRQUFTO1FBQVE7UUFBVTtRQUFhO0tBQU87SUFDN0UsSUFBSUEsWUFBWUwsSUFBSSxDQUFDTSxDQUFBQSxTQUFVVCxLQUFLSyxRQUFRLENBQUNJLFVBQVU7UUFDckQsT0FBTztJQUNUO0lBRUEsc0JBQXNCO0lBQ3RCLElBQUlSLFNBQVMsZ0JBQWdCLE9BQU87SUFDcEMsSUFBSUEsU0FBUyxhQUFhQSxTQUFTLFNBQVMsT0FBTztJQUVuRCxPQUFPO0FBQ1Q7QUFFQSxnRUFBZ0U7QUFDaEUsTUFBTVMsZ0JBQWdCLENBQUNDLE9BQVlDLFFBQWVDO0lBQ2hELElBQUlDLFlBQXNFO0lBQzFFLElBQUlDLGlCQUFpQjtJQUVyQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUosT0FBT0ssTUFBTSxFQUFFRCxJQUFLO1FBQ3RDLElBQUlILFlBQVlLLEdBQUcsQ0FBQ0YsSUFBSTtRQUV4QixNQUFNRyxRQUFRUCxNQUFNLENBQUNJLEVBQUU7UUFDdkIsTUFBTUksYUFB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QVFMLFlBQVlNO0lBQ3BELE1BQU1nQixrQkFBa0JkLFlBQVllLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRW5GLElBQUksS0FBSyxhQUFhbUYsRUFBRW5GLElBQUksS0FBSyxnQkFBZ0JnQixNQUFNO0lBQ3pHLE1BQU1vRSxnQkFBZ0JqQixZQUFZZSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVuRixJQUFJLEtBQUssV0FBV2dCLE1BQU07SUFDMUUsTUFBTXFFLGNBQWNsQixZQUFZZSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVuRixJQUFJLEtBQUssU0FBU2dCLE1BQU07SUFDdEUsTUFBTXNFLGtCQUFrQnBDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHNkIsY0FBY2IsWUFBWW5ELE1BQU07SUFFcEUsNEJBQTRCO0lBQzVCLE1BQU11RSxnQkFBZ0JwQixZQUFZZSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVkLFFBQVEsS0FBSyxZQUFZckQsTUFBTTtJQUMvRSxNQUFNd0UsWUFBWXJCLFlBQVllLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRWQsUUFBUSxLQUFLLFFBQVFyRCxNQUFNO0lBQ3ZFLE1BQU15RSxjQUFjdEIsWUFBWWUsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFZCxRQUFRLEtBQUssVUFBVXJELE1BQU07SUFDM0UsTUFBTTBFLFdBQVd2QixZQUFZZSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVkLFFBQVEsS0FBSyxPQUFPckQsTUFBTTtJQUVyRSxPQUFPO1FBQ0wyRSxXQUFXeEIsWUFBWW5ELE1BQU0sS0FBSztRQUNsQ21EO1FBQ0F5QixTQUFTO1lBQ1BaO1lBQ0FNO1lBQ0FMO1lBQ0FHO1lBQ0FDO1lBQ0FFO1lBQ0FDO1lBQ0FDO1lBQ0FDO1FBQ0Y7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2NvbXBhcmlzb24tZW5naW5lLnRzPzU5ODYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQWR2YW5jZWQgQ29tcGFyaXNvbiBFbmdpbmUgLSBNaWdyYXRlZCBmcm9tIFJlYWN0IHByb2plY3Rcbi8vIFRoaXMgaXMgdGhlIGNvcmUgY29tcGFyaXNvbiBsb2dpYyB0aGF0IG1ha2VzIG91ciBwcm9kdWN0IHdvcmxkLWNsYXNzXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGlmZkl0ZW0ge1xuICBwYXRoOiBzdHJpbmc7XG4gIHR5cGU6ICdtaXNzaW5nJyB8ICdleHRyYScgfCAnY2hhbmdlZCcgfCAndHlwZS1jaGFuZ2VkJztcbiAgb2xkVmFsdWU/OiBhbnk7XG4gIG5ld1ZhbHVlPzogYW55O1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBhcmlzb25SZXN1bHQge1xuICBpZGVudGljYWw6IGJvb2xlYW47XG4gIGRpZmZlcmVuY2VzOiBEaWZmSXRlbVtdO1xuICBzdW1tYXJ5OiB7XG4gICAgdG90YWxGaWVsZHM6IG51bWJlcjtcbiAgICBpZGVudGljYWxGaWVsZHM6IG51bWJlcjtcbiAgICBkaWZmZXJlbnRGaWVsZHM6IG51bWJlcjtcbiAgICBtaXNzaW5nRmllbGRzOiBudW1iZXI7XG4gICAgZXh0cmFGaWVsZHM6IG51bWJlcjtcbiAgICBjcml0aWNhbERpZmZzOiBudW1iZXI7XG4gICAgaGlnaERpZmZzOiBudW1iZXI7XG4gICAgbWVkaXVtRGlmZnM6IG51bWJlcjtcbiAgICBsb3dEaWZmczogbnVtYmVyO1xuICB9O1xufVxuXG4vLyBTZXZlcml0eSBjbGFzc2lmaWNhdGlvbiBiYXNlZCBvbiBwYXRoIGFuZCB0eXBlXG5jb25zdCBnZXRTZXZlcml0eSA9IChwYXRoOiBzdHJpbmcsIHR5cGU6IHN0cmluZyk6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCcgfCAnY3JpdGljYWwnID0+IHtcbiAgLy8gQ3JpdGljYWwgcGF0aHMgdGhhdCBzaG91bGQgbmV2ZXIgY2hhbmdlXG4gIGNvbnN0IGNyaXRpY2FsUGF0aHMgPSBbJ2lkJywgJ3N0YXR1cycsICdlcnJvcicsICdzdWNjZXNzJywgJ2NvZGUnXTtcbiAgaWYgKGNyaXRpY2FsUGF0aHMuc29tZShjcml0aWNhbCA9PiBwYXRoLmluY2x1ZGVzKGNyaXRpY2FsKSkpIHtcbiAgICByZXR1cm4gJ2NyaXRpY2FsJztcbiAgfVxuICBcbiAgLy8gSGlnaCBpbXBvcnRhbmNlIHBhdGhzXG4gIGNvbnN0IGhpZ2hQYXRocyA9IFsnZGF0YScsICdyZXN1bHQnLCAncmVzcG9uc2UnLCAnbWVzc2FnZScsICd0aXRsZScsICduYW1lJ107XG4gIGlmIChoaWdoUGF0aHMuc29tZShoaWdoID0+IHBhdGguaW5jbHVkZXMoaGlnaCkpKSB7XG4gICAgcmV0dXJuICdoaWdoJztcbiAgfVxuICBcbiAgLy8gTWVkaXVtIGltcG9ydGFuY2UgcGF0aHNcbiAgY29uc3QgbWVkaXVtUGF0aHMgPSBbJ2NvdW50JywgJ3RvdGFsJywgJ3NpemUnLCAnbGVuZ3RoJywgJ3RpbWVzdGFtcCcsICdkYXRlJ107XG4gIGlmIChtZWRpdW1QYXRocy5zb21lKG1lZGl1bSA9PiBwYXRoLmluY2x1ZGVzKG1lZGl1bSkpKSB7XG4gICAgcmV0dXJuICdtZWRpdW0nO1xuICB9XG4gIFxuICAvLyBUeXBlLWJhc2VkIHNldmVyaXR5XG4gIGlmICh0eXBlID09PSAndHlwZS1jaGFuZ2VkJykgcmV0dXJuICdoaWdoJztcbiAgaWYgKHR5cGUgPT09ICdtaXNzaW5nJyB8fCB0eXBlID09PSAnZXh0cmEnKSByZXR1cm4gJ21lZGl1bSc7XG4gIFxuICByZXR1cm4gJ2xvdyc7XG59O1xuXG4vLyBBZHZhbmNlZCBzaW1pbGFyaXR5IG1hdGNoaW5nIGZvciBpbnRlbGxpZ2VudCBhcnJheSBjb21wYXJpc29uXG5jb25zdCBmaW5kQmVzdE1hdGNoID0gKGl0ZW1BOiBhbnksIGFycmF5QjogYW55W10sIHVzZWRJbmRpY2VzOiBTZXQ8bnVtYmVyPik6IHsgbWF0Y2g6IGFueSwgaW5kZXg6IG51bWJlciwgc2ltaWxhcml0eTogbnVtYmVyIH0gfCBudWxsID0+IHtcbiAgbGV0IGJlc3RNYXRjaDogeyBtYXRjaDogYW55LCBpbmRleDogbnVtYmVyLCBzaW1pbGFyaXR5OiBudW1iZXIgfSB8IG51bGwgPSBudWxsO1xuICBsZXQgYmVzdFNpbWlsYXJpdHkgPSAwO1xuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheUIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodXNlZEluZGljZXMuaGFzKGkpKSBjb250aW51ZTtcbiAgICBcbiAgICBjb25zdCBpdGVtQiA9IGFycmF5QltpXTtcbiAgICBjb25zdCBzaW1pbGFyaXR5ID0gY2FsY3VsYXRlU2ltaWxhcml0eShpdGVtQSwgaXRlbUIpO1xuICAgIFxuICAgIGlmIChzaW1pbGFyaXR5ID4gYmVzdFNpbWlsYXJpdHkgJiYgc2ltaWxhcml0eSA+PSAwLjUpIHtcbiAgICAgIGJlc3RNYXRjaCA9IHsgbWF0Y2g6IGl0ZW1CLCBpbmRleDogaSwgc2ltaWxhcml0eSB9O1xuICAgICAgYmVzdFNpbWlsYXJpdHkgPSBzaW1pbGFyaXR5O1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIGJlc3RNYXRjaDtcbn07XG5cbi8vIENhbGN1bGF0ZSBzaW1pbGFyaXR5IGJldHdlZW4gdHdvIG9iamVjdHMgKDAtMSBzY2FsZSlcbmNvbnN0IGNhbGN1bGF0ZVNpbWlsYXJpdHkgPSAoYTogYW55LCBiOiBhbnkpOiBudW1iZXIgPT4ge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIDEuMDtcbiAgaWYgKHR5cGVvZiBhICE9PSB0eXBlb2YgYikgcmV0dXJuIDAuMDtcbiAgXG4gIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICBpZiAoYS5sZW5ndGggPT09IDAgJiYgYi5sZW5ndGggPT09IDApIHJldHVybiAxLjA7XG4gICAgaWYgKGEubGVuZ3RoID09PSAwIHx8IGIubGVuZ3RoID09PSAwKSByZXR1cm4gMC4wO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIHNpbWlsYXJpdHkgb2YgYXJyYXkgZWxlbWVudHNcbiAgICBjb25zdCBzaW1pbGFyaXRpZXMgPSBhLm1hcChpdGVtQSA9PiB7XG4gICAgICBjb25zdCBiZXN0TWF0Y2ggPSBmaW5kQmVzdE1hdGNoKGl0ZW1BLCBiLCBuZXcgU2V0KCkpO1xuICAgICAgcmV0dXJuIGJlc3RNYXRjaCA/IGJlc3RNYXRjaC5zaW1pbGFyaXR5IDogMDtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gc2ltaWxhcml0aWVzLnJlZHVjZSgoc3VtLCBzaW0pID0+IHN1bSArIHNpbSwgMCkgLyBzaW1pbGFyaXRpZXMubGVuZ3RoO1xuICB9XG4gIFxuICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICBjb25zdCBhbGxLZXlzID0gbmV3IFNldChbLi4ua2V5c0EsIC4uLmtleXNCXSk7XG4gICAgXG4gICAgaWYgKGFsbEtleXMuc2l6ZSA9PT0gMCkgcmV0dXJuIDEuMDtcbiAgICBcbiAgICBsZXQgbWF0Y2hpbmdLZXlzID0gMDtcbiAgICBsZXQgdG90YWxTaW1pbGFyaXR5ID0gMDtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBhbGxLZXlzKSB7XG4gICAgICBpZiAoa2V5IGluIGEgJiYga2V5IGluIGIpIHtcbiAgICAgICAgbWF0Y2hpbmdLZXlzKys7XG4gICAgICAgIHRvdGFsU2ltaWxhcml0eSArPSBjYWxjdWxhdGVTaW1pbGFyaXR5KGFba2V5XSwgYltrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3Qga2V5U2ltaWxhcml0eSA9IG1hdGNoaW5nS2V5cyAvIGFsbEtleXMuc2l6ZTtcbiAgICBjb25zdCB2YWx1ZVNpbWlsYXJpdHkgPSBtYXRjaGluZ0tleXMgPiAwID8gdG90YWxTaW1pbGFyaXR5IC8gbWF0Y2hpbmdLZXlzIDogMDtcbiAgICBcbiAgICByZXR1cm4gKGtleVNpbWlsYXJpdHkgKyB2YWx1ZVNpbWlsYXJpdHkpIC8gMjtcbiAgfVxuICBcbiAgLy8gRm9yIHByaW1pdGl2ZXMsIHVzZSBzdHJpbmcgc2ltaWxhcml0eVxuICBjb25zdCBzdHJBID0gU3RyaW5nKGEpO1xuICBjb25zdCBzdHJCID0gU3RyaW5nKGIpO1xuICBcbiAgaWYgKHN0ckEgPT09IHN0ckIpIHJldHVybiAxLjA7XG4gIGlmIChzdHJBLmxlbmd0aCA9PT0gMCAmJiBzdHJCLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDEuMDtcbiAgaWYgKHN0ckEubGVuZ3RoID09PSAwIHx8IHN0ckIubGVuZ3RoID09PSAwKSByZXR1cm4gMC4wO1xuICBcbiAgLy8gU2ltcGxlIExldmVuc2h0ZWluIGRpc3RhbmNlLWJhc2VkIHNpbWlsYXJpdHlcbiAgY29uc3QgZGlzdGFuY2UgPSBsZXZlbnNodGVpbkRpc3RhbmNlKHN0ckEsIHN0ckIpO1xuICBjb25zdCBtYXhMZW5ndGggPSBNYXRoLm1heChzdHJBLmxlbmd0aCwgc3RyQi5sZW5ndGgpO1xuICByZXR1cm4gMSAtIChkaXN0YW5jZSAvIG1heExlbmd0aCk7XG59O1xuXG4vLyBMZXZlbnNodGVpbiBkaXN0YW5jZSBjYWxjdWxhdGlvblxuY29uc3QgbGV2ZW5zaHRlaW5EaXN0YW5jZSA9IChzdHIxOiBzdHJpbmcsIHN0cjI6IHN0cmluZyk6IG51bWJlciA9PiB7XG4gIGNvbnN0IG1hdHJpeCA9IEFycmF5KHN0cjIubGVuZ3RoICsgMSkuZmlsbChudWxsKS5tYXAoKCkgPT4gQXJyYXkoc3RyMS5sZW5ndGggKyAxKS5maWxsKG51bGwpKTtcbiAgXG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IHN0cjEubGVuZ3RoOyBpKyspIG1hdHJpeFswXVtpXSA9IGk7XG4gIGZvciAobGV0IGogPSAwOyBqIDw9IHN0cjIubGVuZ3RoOyBqKyspIG1hdHJpeFtqXVswXSA9IGo7XG4gIFxuICBmb3IgKGxldCBqID0gMTsgaiA8PSBzdHIyLmxlbmd0aDsgaisrKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gc3RyMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5kaWNhdG9yID0gc3RyMVtpIC0gMV0gPT09IHN0cjJbaiAtIDFdID8gMCA6IDE7XG4gICAgICBtYXRyaXhbal1baV0gPSBNYXRoLm1pbihcbiAgICAgICAgbWF0cml4W2pdW2kgLSAxXSArIDEsICAgICAvLyBkZWxldGlvblxuICAgICAgICBtYXRyaXhbaiAtIDFdW2ldICsgMSwgICAgIC8vIGluc2VydGlvblxuICAgICAgICBtYXRyaXhbaiAtIDFdW2kgLSAxXSArIGluZGljYXRvciAvLyBzdWJzdGl0dXRpb25cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gbWF0cml4W3N0cjIubGVuZ3RoXVtzdHIxLmxlbmd0aF07XG59O1xuXG4vLyBDb3VudCBmaWVsZHMgaW4gYW4gb2JqZWN0IGZvciBzdGF0aXN0aWNzXG5jb25zdCBjb3VudEZpZWxkcyA9IChvYmo6IGFueSk6IG51bWJlciA9PiB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHJldHVybiAxO1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSByZXR1cm4gb2JqLnJlZHVjZSgoc3VtLCBpdGVtKSA9PiBzdW0gKyBjb3VudEZpZWxkcyhpdGVtKSwgMCk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgoc3VtLCBrZXkpID0+IHN1bSArIGNvdW50RmllbGRzKG9ialtrZXldKSwgMCk7XG59O1xuXG4vLyBNYWluIGNvbXBhcmlzb24gZnVuY3Rpb24gLSB0aGUgaGVhcnQgb2Ygb3VyIHByb2R1Y3RcbmV4cG9ydCBjb25zdCBjb21wYXJlSnNvbkRhdGEgPSAob2JqMTogYW55LCBvYmoyOiBhbnksIGlzT3JkZXJTZW5zaXRpdmU6IGJvb2xlYW4gPSBmYWxzZSk6IENvbXBhcmlzb25SZXN1bHQgPT4ge1xuICBjb25zdCBkaWZmZXJlbmNlczogRGlmZkl0ZW1bXSA9IFtdO1xuICBcbiAgY29uc3QgY29tcGFyZSA9IChhOiBhbnksIGI6IGFueSwgcGF0aDogc3RyaW5nID0gJycpID0+IHtcbiAgICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiKSB7XG4gICAgICBjb25zdCBzZXZlcml0eSA9IGdldFNldmVyaXR5KHBhdGgsICd0eXBlLWNoYW5nZWQnKTtcbiAgICAgIGRpZmZlcmVuY2VzLnB1c2goe1xuICAgICAgICBwYXRoLFxuICAgICAgICB0eXBlOiAndHlwZS1jaGFuZ2VkJyxcbiAgICAgICAgc2V2ZXJpdHksXG4gICAgICAgIG9sZFZhbHVlOiBhLFxuICAgICAgICBuZXdWYWx1ZTogYixcbiAgICAgICAgZGVzY3JpcHRpb246IGBUeXBlIGNoYW5nZWQgZnJvbSAke3R5cGVvZiBhfSB0byAke3R5cGVvZiBifWBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgIGlmIChpc09yZGVyU2Vuc2l0aXZlKSB7XG4gICAgICAgIC8vIE9yZGVyLXNlbnNpdGl2ZSBhcnJheSBjb21wYXJpc29uIChzdHJpY3QgcG9zaXRpb25hbCBtYXRjaGluZylcbiAgICAgICAgY29uc3QgbWF4TGVuZ3RoID0gTWF0aC5tYXgoYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChpID49IGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzZXZlcml0eSA9IGdldFNldmVyaXR5KGAke3BhdGh9WyR7aX1dYCwgJ2V4dHJhJyk7XG4gICAgICAgICAgICBkaWZmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgcGF0aDogYCR7cGF0aH1bJHtpfV1gLFxuICAgICAgICAgICAgICB0eXBlOiAnZXh0cmEnLFxuICAgICAgICAgICAgICBzZXZlcml0eSxcbiAgICAgICAgICAgICAgb2xkVmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgbmV3VmFsdWU6IGJbaV0sXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgRXh0cmEgYXJyYXkgaXRlbSBhdCBwb3NpdGlvbiAke2l9IChvcmRlci1zZW5zaXRpdmUpYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID49IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzZXZlcml0eSA9IGdldFNldmVyaXR5KGAke3BhdGh9WyR7aX1dYCwgJ21pc3NpbmcnKTtcbiAgICAgICAgICAgIGRpZmZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICBwYXRoOiBgJHtwYXRofVske2l9XWAsXG4gICAgICAgICAgICAgIHR5cGU6ICdtaXNzaW5nJyxcbiAgICAgICAgICAgICAgc2V2ZXJpdHksXG4gICAgICAgICAgICAgIG9sZFZhbHVlOiBhW2ldLFxuICAgICAgICAgICAgICBuZXdWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYE1pc3NpbmcgYXJyYXkgaXRlbSBhdCBwb3NpdGlvbiAke2l9IChvcmRlci1zZW5zaXRpdmUpYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBhcmUoYVtpXSwgYltpXSwgYCR7cGF0aH1bJHtpfV1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRSVUxZIElOVEVMTElHRU5UIE9SREVSLUlOU0VOU0lUSVZFIEFSUkFZIENPTVBBUklTT05cbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgY29yZSBhbGdvcml0aG0gdGhhdCBtYWtlcyBvdXIgcHJvZHVjdCB3b3JsZC1jbGFzc1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdXNlZEluZGljZXNJbkIgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgICAgICAgY29uc3QgdW5tYXRjaGVkRnJvbUE6IEFycmF5PHtpdGVtOiBhbnksIG9yaWdpbmFsSW5kZXg6IG51bWJlcn0+ID0gW107XG4gICAgICAgIFxuICAgICAgICAvLyBQaGFzZSAxOiBGaW5kIGV4YWN0IG1hdGNoZXMgYW5kIGhpZ2gtc2ltaWxhcml0eSBtYXRjaGVzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGl0ZW1BID0gYVtpXTtcbiAgICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSBmaW5kQmVzdE1hdGNoKGl0ZW1BLCBiLCB1c2VkSW5kaWNlc0luQik7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGJlc3RNYXRjaCAmJiBiZXN0TWF0Y2guc2ltaWxhcml0eSA+PSAwLjk1KSB7XG4gICAgICAgICAgICAvLyBFeGFjdCBvciBuZWFyLWV4YWN0IG1hdGNoIGZvdW5kXG4gICAgICAgICAgICB1c2VkSW5kaWNlc0luQi5hZGQoYmVzdE1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGJlc3RNYXRjaC5zaW1pbGFyaXR5IDwgMS4wKSB7XG4gICAgICAgICAgICAgIC8vIEl0ZW1zIGFyZSBzaW1pbGFyIGJ1dCBub3QgaWRlbnRpY2FsIC0gY29tcGFyZSB0aGVtIGZvciBkZXRhaWxlZCBkaWZmZXJlbmNlc1xuICAgICAgICAgICAgICBjb21wYXJlKGl0ZW1BLCBiZXN0TWF0Y2gubWF0Y2gsIGAke3BhdGh9WyR7aX1dYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBzaW1pbGFyaXR5IGlzIDEuMCwgaXRlbXMgYXJlIGlkZW50aWNhbCAtIG5vIGRpZmZlcmVuY2VzIHRvIHJlcG9ydFxuICAgICAgICAgIH0gZWxzZSBpZiAoYmVzdE1hdGNoICYmIGJlc3RNYXRjaC5zaW1pbGFyaXR5ID49IDAuNykge1xuICAgICAgICAgICAgLy8gUGFydGlhbCBtYXRjaCAtIHRoZXNlIGFyZSBsaWtlbHkgdGhlIHNhbWUgbG9naWNhbCBpdGVtIHdpdGggc29tZSBjaGFuZ2VzXG4gICAgICAgICAgICB1c2VkSW5kaWNlc0luQi5hZGQoYmVzdE1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIGNvbXBhcmUoaXRlbUEsIGJlc3RNYXRjaC5tYXRjaCwgYCR7cGF0aH1bJHtpfV1gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gZ29vZCBtYXRjaCBmb3VuZCAtIHRoaXMgaXRlbSBtaWdodCBiZSBtaXNzaW5nIGZyb20gQlxuICAgICAgICAgICAgdW5tYXRjaGVkRnJvbUEucHVzaCh7IGl0ZW06IGl0ZW1BLCBvcmlnaW5hbEluZGV4OiBpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUGhhc2UgMjogSWRlbnRpZnkgdHJ1bHkgbWlzc2luZyBpdGVtcyAoZnJvbSBBIGJ1dCBub3QgaW4gQilcbiAgICAgICAgZm9yIChjb25zdCB1bm1hdGNoZWQgb2YgdW5tYXRjaGVkRnJvbUEpIHtcbiAgICAgICAgICBjb25zdCBzZXZlcml0eSA9IGdldFNldmVyaXR5KGAke3BhdGh9WyR7dW5tYXRjaGVkLm9yaWdpbmFsSW5kZXh9XWAsICdtaXNzaW5nJyk7XG4gICAgICAgICAgZGlmZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICBwYXRoOiBgJHtwYXRofVske3VubWF0Y2hlZC5vcmlnaW5hbEluZGV4fV1gLFxuICAgICAgICAgICAgdHlwZTogJ21pc3NpbmcnLFxuICAgICAgICAgICAgc2V2ZXJpdHksXG4gICAgICAgICAgICBvbGRWYWx1ZTogdW5tYXRjaGVkLml0ZW0sXG4gICAgICAgICAgICBuZXdWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBJdGVtIGZyb20gTGl2ZSBBUEkgbm90IGZvdW5kIGluIE5ldyBBUEkgKG5vIHNpbWlsYXIgbWF0Y2ggZm91bmQpYFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBQaGFzZSAzOiBJZGVudGlmeSB0cnVseSBleHRyYSBpdGVtcyAoaW4gQiBidXQgbm90IG1hdGNoZWQgd2l0aCBBKVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoIXVzZWRJbmRpY2VzSW5CLmhhcyhqKSkge1xuICAgICAgICAgICAgY29uc3Qgc2V2ZXJpdHkgPSBnZXRTZXZlcml0eShgJHtwYXRofVske2p9XWAsICdleHRyYScpO1xuICAgICAgICAgICAgZGlmZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHBhdGg6IGAke3BhdGh9WyR7an1dYCxcbiAgICAgICAgICAgICAgdHlwZTogJ2V4dHJhJyxcbiAgICAgICAgICAgICAgc2V2ZXJpdHksXG4gICAgICAgICAgICAgIG9sZFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIG5ld1ZhbHVlOiBiW2pdLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYE5ldyBpdGVtIGluIE5ldyBBUEkgbm90IGZvdW5kIGluIExpdmUgQVBJYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhICE9PSBudWxsICYmIGIgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGFsbEtleXMgPSBuZXcgU2V0KFsuLi5PYmplY3Qua2V5cyhhKSwgLi4uT2JqZWN0LmtleXMoYildKTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgYWxsS2V5cykge1xuICAgICAgICBjb25zdCBuZXdQYXRoID0gcGF0aCA/IGAke3BhdGh9LiR7a2V5fWAgOiBrZXk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIShrZXkgaW4gYSkpIHtcbiAgICAgICAgICBjb25zdCBzZXZlcml0eSA9IGdldFNldmVyaXR5KG5ld1BhdGgsICdleHRyYScpO1xuICAgICAgICAgIGRpZmZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgcGF0aDogbmV3UGF0aCxcbiAgICAgICAgICAgIHR5cGU6ICdleHRyYScsXG4gICAgICAgICAgICBzZXZlcml0eSxcbiAgICAgICAgICAgIG9sZFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBuZXdWYWx1ZTogYltrZXldLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBQcm9wZXJ0eSAnJHtrZXl9JyBleGlzdHMgb25seSBpbiByaWdodCBvYmplY3RgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIShrZXkgaW4gYikpIHtcbiAgICAgICAgICBjb25zdCBzZXZlcml0eSA9IGdldFNldmVyaXR5KG5ld1BhdGgsICdtaXNzaW5nJyk7XG4gICAgICAgICAgZGlmZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICBwYXRoOiBuZXdQYXRoLFxuICAgICAgICAgICAgdHlwZTogJ21pc3NpbmcnLFxuICAgICAgICAgICAgc2V2ZXJpdHksXG4gICAgICAgICAgICBvbGRWYWx1ZTogYVtrZXldLFxuICAgICAgICAgICAgbmV3VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgUHJvcGVydHkgJyR7a2V5fScgZXhpc3RzIG9ubHkgaW4gbGVmdCBvYmplY3RgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGFyZShhW2tleV0sIGJba2V5XSwgbmV3UGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgY29uc3Qgc2V2ZXJpdHkgPSBnZXRTZXZlcml0eShwYXRoLCAnY2hhbmdlZCcpO1xuICAgICAgZGlmZmVyZW5jZXMucHVzaCh7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHR5cGU6ICdjaGFuZ2VkJyxcbiAgICAgICAgc2V2ZXJpdHksXG4gICAgICAgIG9sZFZhbHVlOiBhLFxuICAgICAgICBuZXdWYWx1ZTogYixcbiAgICAgICAgZGVzY3JpcHRpb246IGBWYWx1ZSBjaGFuZ2VkIGZyb20gJyR7YX0nIHRvICcke2J9J2BcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBjb21wYXJlKG9iajEsIG9iajIpO1xuXG4gIC8vIENhbGN1bGF0ZSBzdW1tYXJ5IHN0YXRpc3RpY3NcbiAgY29uc3QgdG90YWxGaWVsZHMgPSBjb3VudEZpZWxkcyhvYmoxKSArIGNvdW50RmllbGRzKG9iajIpO1xuICBjb25zdCBkaWZmZXJlbnRGaWVsZHMgPSBkaWZmZXJlbmNlcy5maWx0ZXIoZCA9PiBkLnR5cGUgPT09ICdjaGFuZ2VkJyB8fCBkLnR5cGUgPT09ICd0eXBlLWNoYW5nZWQnKS5sZW5ndGg7XG4gIGNvbnN0IG1pc3NpbmdGaWVsZHMgPSBkaWZmZXJlbmNlcy5maWx0ZXIoZCA9PiBkLnR5cGUgPT09ICdtaXNzaW5nJykubGVuZ3RoO1xuICBjb25zdCBleHRyYUZpZWxkcyA9IGRpZmZlcmVuY2VzLmZpbHRlcihkID0+IGQudHlwZSA9PT0gJ2V4dHJhJykubGVuZ3RoO1xuICBjb25zdCBpZGVudGljYWxGaWVsZHMgPSBNYXRoLm1heCgwLCB0b3RhbEZpZWxkcyAtIGRpZmZlcmVuY2VzLmxlbmd0aCk7XG4gIFxuICAvLyBDYWxjdWxhdGUgc2V2ZXJpdHkgY291bnRzXG4gIGNvbnN0IGNyaXRpY2FsRGlmZnMgPSBkaWZmZXJlbmNlcy5maWx0ZXIoZCA9PiBkLnNldmVyaXR5ID09PSAnY3JpdGljYWwnKS5sZW5ndGg7XG4gIGNvbnN0IGhpZ2hEaWZmcyA9IGRpZmZlcmVuY2VzLmZpbHRlcihkID0+IGQuc2V2ZXJpdHkgPT09ICdoaWdoJykubGVuZ3RoO1xuICBjb25zdCBtZWRpdW1EaWZmcyA9IGRpZmZlcmVuY2VzLmZpbHRlcihkID0+IGQuc2V2ZXJpdHkgPT09ICdtZWRpdW0nKS5sZW5ndGg7XG4gIGNvbnN0IGxvd0RpZmZzID0gZGlmZmVyZW5jZXMuZmlsdGVyKGQgPT4gZC5zZXZlcml0eSA9PT0gJ2xvdycpLmxlbmd0aDtcblxuICByZXR1cm4ge1xuICAgIGlkZW50aWNhbDogZGlmZmVyZW5jZXMubGVuZ3RoID09PSAwLFxuICAgIGRpZmZlcmVuY2VzLFxuICAgIHN1bW1hcnk6IHtcbiAgICAgIHRvdGFsRmllbGRzLFxuICAgICAgaWRlbnRpY2FsRmllbGRzLFxuICAgICAgZGlmZmVyZW50RmllbGRzLFxuICAgICAgbWlzc2luZ0ZpZWxkcyxcbiAgICAgIGV4dHJhRmllbGRzLFxuICAgICAgY3JpdGljYWxEaWZmcyxcbiAgICAgIGhpZ2hEaWZmcyxcbiAgICAgIG1lZGl1bURpZmZzLFxuICAgICAgbG93RGlmZnNcbiAgICB9XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbImdldFNldmVyaXR5IiwicGF0aCIsInR5cGUiLCJjcml0aWNhbFBhdGhzIiwic29tZSIsImNyaXRpY2FsIiwiaW5jbHVkZXMiLCJoaWdoUGF0aHMiLCJoaWdoIiwibWVkaXVtUGF0aHMiLCJtZWRpdW0iLCJmaW5kQmVzdE1hdGNoIiwiaXRlbUEiLCJhcnJheUIiLCJ1c2VkSW5kaWNlcyIsImJlc3RNYXRjaCIsImJlc3RTaW1pbGFyaXR5IiwiaSIsImxlbmd0aCIsImhhcyIsIml0ZW1CIiwic2ltaWxhcml0eSIsImNhbGN1bGF0ZVNpbWlsYXJpdHkiLCJtYXRjaCIsImluZGV4IiwiYSIsImIiLCJBcnJheSIsImlzQXJyYXkiLCJzaW1pbGFyaXRpZXMiLCJtYXAiLCJTZXQiLCJyZWR1Y2UiLCJzdW0iLCJzaW0iLCJrZXlzQSIsIk9iamVjdCIsImtleXMiLCJrZXlzQiIsImFsbEtleXMiLCJzaXplIiwibWF0Y2hpbmdLZXlzIiwidG90YWxTaW1pbGFyaXR5Iiwia2V5Iiwia2V5U2ltaWxhcml0eSIsInZhbHVlU2ltaWxhcml0eSIsInN0ckEiLCJTdHJpbmciLCJzdHJCIiwiZGlzdGFuY2UiLCJsZXZlbnNodGVpbkRpc3RhbmNlIiwibWF4TGVuZ3RoIiwiTWF0aCIsIm1heCIsInN0cjEiLCJzdHIyIiwibWF0cml4IiwiZmlsbCIsImoiLCJpbmRpY2F0b3IiLCJtaW4iLCJjb3VudEZpZWxkcyIsIm9iaiIsInVuZGVmaW5lZCIsIml0ZW0iLCJjb21wYXJlSnNvbkRhdGEiLCJvYmoxIiwib2JqMiIsImlzT3JkZXJTZW5zaXRpdmUiLCJkaWZmZXJlbmNlcyIsImNvbXBhcmUiLCJzZXZlcml0eSIsInB1c2giLCJvbGRWYWx1ZSIsIm5ld1ZhbHVlIiwiZGVzY3JpcHRpb24iLCJ1c2VkSW5kaWNlc0luQiIsInVubWF0Y2hlZEZyb21BIiwiYWRkIiwib3JpZ2luYWxJbmRleCIsInVubWF0Y2hlZCIsIm5ld1BhdGgiLCJ0b3RhbEZpZWxkcyIsImRpZmZlcmVudEZpZWxkcyIsImZpbHRlciIsImQiLCJtaXNzaW5nRmllbGRzIiwiZXh0cmFGaWVsZHMiLCJpZGVudGljYWxGaWVsZHMiLCJjcml0aWNhbERpZmZzIiwiaGlnaERpZmZzIiwibWVkaXVtRGlmZnMiLCJsb3dEaWZmcyIsImlkZW50aWNhbCIsInN1bW1hcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/comparison-engine.ts\n"));

/***/ })

});